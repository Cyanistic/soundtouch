#![allow(non_snake_case, non_camel_case_types, unused)]
/* automatically generated by rust-bindgen 0.68.1 */

pub type uint = ::std::os::raw::c_uint;
pub type soundtouch_SAMPLETYPE = f32;
#[repr(C)]
pub struct soundtouch_FIFOSamplePipe__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Abstract base class for FIFO (first-in-first-out) sample processing classes."]
#[repr(C)]
#[derive(Debug)]
pub struct soundtouch_FIFOSamplePipe {
    pub vtable_: *const soundtouch_FIFOSamplePipe__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_soundtouch_FIFOSamplePipe() {
    assert_eq!(
        ::std::mem::size_of::<soundtouch_FIFOSamplePipe>(),
        8usize,
        concat!("Size of: ", stringify!(soundtouch_FIFOSamplePipe))
    );
    assert_eq!(
        ::std::mem::align_of::<soundtouch_FIFOSamplePipe>(),
        8usize,
        concat!("Alignment of ", stringify!(soundtouch_FIFOSamplePipe))
    );
}
#[doc = " Base-class for sound processing routines working in FIFO principle. With this base\n class it's easy to implement sound processing stages that can be chained together,\n so that samples that are fed into beginning of the pipe automatically go through\n all the processing stages.\n\n When samples are input to this class, they're first processed and then put to\n the FIFO pipe that's defined as output of this class. This output pipe can be\n either other processing stage or a FIFO sample buffer."]
#[repr(C)]
#[derive(Debug)]
pub struct soundtouch_FIFOProcessor {
    pub _base: soundtouch_FIFOSamplePipe,
    #[doc = " Internal pipe where processed samples are put."]
    pub output: *mut soundtouch_FIFOSamplePipe,
}
#[test]
fn bindgen_test_layout_soundtouch_FIFOProcessor() {
    const UNINIT: ::std::mem::MaybeUninit<soundtouch_FIFOProcessor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<soundtouch_FIFOProcessor>(),
        16usize,
        concat!("Size of: ", stringify!(soundtouch_FIFOProcessor))
    );
    assert_eq!(
        ::std::mem::align_of::<soundtouch_FIFOProcessor>(),
        8usize,
        concat!("Alignment of ", stringify!(soundtouch_FIFOProcessor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(soundtouch_FIFOProcessor),
            "::",
            stringify!(output)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct soundtouch_SoundTouch {
    pub _base: soundtouch_FIFOProcessor,
    #[doc = " Rate transposer class instance"]
    pub pRateTransposer: *mut RateTransposer,
    #[doc = " Time-stretch class instance"]
    pub pTDStretch: *mut TDStretch,
    #[doc = " Virtual pitch parameter. Effective rate & tempo are calculated from these parameters."]
    pub virtualRate: f64,
    #[doc = " Virtual pitch parameter. Effective rate & tempo are calculated from these parameters."]
    pub virtualTempo: f64,
    #[doc = " Virtual pitch parameter. Effective rate & tempo are calculated from these parameters."]
    pub virtualPitch: f64,
    #[doc = " Flag: Has sample rate been set?"]
    pub bSrateSet: bool,
    #[doc = " Accumulator for how many samples in total will be expected as output vs. samples put in,\n considering current processing settings."]
    pub samplesExpectedOut: f64,
    #[doc = " Accumulator for how many samples in total have been read out from the processing so far"]
    pub samplesOutput: ::std::os::raw::c_long,
    #[doc = " Number of channels"]
    pub channels: uint,
    #[doc = " Effective 'rate' value calculated from 'virtualRate', 'virtualTempo' and 'virtualPitch'"]
    pub rate: f64,
    #[doc = " Effective 'tempo' value calculated from 'virtualRate', 'virtualTempo' and 'virtualPitch'"]
    pub tempo: f64,
}
#[test]
fn bindgen_test_layout_soundtouch_SoundTouch() {
    const UNINIT: ::std::mem::MaybeUninit<soundtouch_SoundTouch> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<soundtouch_SoundTouch>(),
        104usize,
        concat!("Size of: ", stringify!(soundtouch_SoundTouch))
    );
    assert_eq!(
        ::std::mem::align_of::<soundtouch_SoundTouch>(),
        8usize,
        concat!("Alignment of ", stringify!(soundtouch_SoundTouch))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pRateTransposer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(soundtouch_SoundTouch),
            "::",
            stringify!(pRateTransposer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pTDStretch) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(soundtouch_SoundTouch),
            "::",
            stringify!(pTDStretch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).virtualRate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(soundtouch_SoundTouch),
            "::",
            stringify!(virtualRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).virtualTempo) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(soundtouch_SoundTouch),
            "::",
            stringify!(virtualTempo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).virtualPitch) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(soundtouch_SoundTouch),
            "::",
            stringify!(virtualPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bSrateSet) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(soundtouch_SoundTouch),
            "::",
            stringify!(bSrateSet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samplesExpectedOut) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(soundtouch_SoundTouch),
            "::",
            stringify!(samplesExpectedOut)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samplesOutput) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(soundtouch_SoundTouch),
            "::",
            stringify!(samplesOutput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(soundtouch_SoundTouch),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(soundtouch_SoundTouch),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tempo) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(soundtouch_SoundTouch),
            "::",
            stringify!(tempo)
        )
    );
}
extern "C" {
    #[doc = " Get SoundTouch library version string"]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch16getVersionStringEv"]
    pub fn soundtouch_SoundTouch_getVersionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get SoundTouch library version Id"]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch12getVersionIdEv"]
    pub fn soundtouch_SoundTouch_getVersionId() -> uint;
}
extern "C" {
    #[doc = " Sets new rate control value. Normal rate = 1.0, smaller values\n represent slower rate, larger faster rates."]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch7setRateEd"]
    pub fn soundtouch_SoundTouch_setRate(this: *mut soundtouch_SoundTouch, newRate: f64);
}
extern "C" {
    #[doc = " Sets new tempo control value. Normal tempo = 1.0, smaller values\n represent slower tempo, larger faster tempo."]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch8setTempoEd"]
    pub fn soundtouch_SoundTouch_setTempo(this: *mut soundtouch_SoundTouch, newTempo: f64);
}
extern "C" {
    #[doc = " Sets new rate control value as a difference in percents compared\n to the original rate (-50 .. +100 %)"]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch13setRateChangeEd"]
    pub fn soundtouch_SoundTouch_setRateChange(this: *mut soundtouch_SoundTouch, newRate: f64);
}
extern "C" {
    #[doc = " Sets new tempo control value as a difference in percents compared\n to the original tempo (-50 .. +100 %)"]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch14setTempoChangeEd"]
    pub fn soundtouch_SoundTouch_setTempoChange(this: *mut soundtouch_SoundTouch, newTempo: f64);
}
extern "C" {
    #[doc = " Sets new pitch control value. Original pitch = 1.0, smaller values\n represent lower pitches, larger values higher pitch."]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch8setPitchEd"]
    pub fn soundtouch_SoundTouch_setPitch(this: *mut soundtouch_SoundTouch, newPitch: f64);
}
extern "C" {
    #[doc = " Sets pitch change in octaves compared to the original pitch\n (-1.00 .. +1.00)"]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch15setPitchOctavesEd"]
    pub fn soundtouch_SoundTouch_setPitchOctaves(this: *mut soundtouch_SoundTouch, newPitch: f64);
}
extern "C" {
    #[doc = " Sets pitch change in semi-tones compared to the original pitch\n (-12 .. +12)"]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch17setPitchSemiTonesEi"]
    pub fn soundtouch_SoundTouch_setPitchSemiTones(
        this: *mut soundtouch_SoundTouch,
        newPitch: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch17setPitchSemiTonesEd"]
    pub fn soundtouch_SoundTouch_setPitchSemiTones1(
        this: *mut soundtouch_SoundTouch,
        newPitch: f64,
    );
}
extern "C" {
    #[doc = " Sets the number of channels, 1 = mono, 2 = stereo"]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch11setChannelsEj"]
    pub fn soundtouch_SoundTouch_setChannels(this: *mut soundtouch_SoundTouch, numChannels: uint);
}
extern "C" {
    #[doc = " Sets sample rate."]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch13setSampleRateEj"]
    pub fn soundtouch_SoundTouch_setSampleRate(this: *mut soundtouch_SoundTouch, srate: uint);
}
extern "C" {
    #[doc = " Get ratio between input and output audio durations, useful for calculating\n processed output duration: if you'll process a stream of N samples, then\n you can expect to get out N * getInputOutputSampleRatio() samples.\n\n This ratio will give accurate target duration ratio for a full audio track,\n given that the the whole track is processed with same processing parameters.\n\n If this ratio is applied to calculate intermediate offsets inside a processing\n stream, then this ratio is approximate and can deviate +- some tens of milliseconds\n from ideal offset, yet by end of the audio stream the duration ratio will become\n exact.\n\n Example: if processing with parameters \"-tempo=15 -pitch=-3\", the function\n will return value 0.8695652... Now, if processing an audio stream whose duration\n is exactly one million audio samples, then you can expect the processed\n output duration  be 0.869565 * 1000000 = 869565 samples."]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch25getInputOutputSampleRatioEv"]
    pub fn soundtouch_SoundTouch_getInputOutputSampleRatio(this: *mut soundtouch_SoundTouch)
        -> f64;
}
extern "C" {
    #[doc = " Note: This function is meant for extracting the last samples of a sound\n stream. This function may introduce additional blank samples in the end\n of the sound stream, and thus it's not recommended to call this function\n in the middle of a sound stream."]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch5flushEv"]
    pub fn soundtouch_SoundTouch_flush(this: *mut soundtouch_SoundTouch);
}
extern "C" {
    #[doc = " Changes a setting controlling the processing system behaviour. See the\n 'SETTING_...' defines for available setting ID's.\n\n \\return 'true' if the setting was successfully changed"]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch10setSettingEii"]
    pub fn soundtouch_SoundTouch_setSetting(
        this: *mut soundtouch_SoundTouch,
        settingId: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Reads a setting controlling the processing system behaviour. See the\n 'SETTING_...' defines for available setting ID's.\n\n \\return the setting value."]
    #[link_name = "\u{1}_ZNK10soundtouch10SoundTouch10getSettingEi"]
    pub fn soundtouch_SoundTouch_getSetting(
        this: *const soundtouch_SoundTouch,
        settingId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouchC1Ev"]
    pub fn soundtouch_SoundTouch_SoundTouch(this: *mut soundtouch_SoundTouch);
}
impl soundtouch_SoundTouch {
    #[inline]
    pub unsafe fn getVersionString() -> *const ::std::os::raw::c_char {
        soundtouch_SoundTouch_getVersionString()
    }
    #[inline]
    pub unsafe fn getVersionId() -> uint {
        soundtouch_SoundTouch_getVersionId()
    }
    #[inline]
    pub unsafe fn setRate(&mut self, newRate: f64) {
        soundtouch_SoundTouch_setRate(self, newRate)
    }
    #[inline]
    pub unsafe fn setTempo(&mut self, newTempo: f64) {
        soundtouch_SoundTouch_setTempo(self, newTempo)
    }
    #[inline]
    pub unsafe fn setRateChange(&mut self, newRate: f64) {
        soundtouch_SoundTouch_setRateChange(self, newRate)
    }
    #[inline]
    pub unsafe fn setTempoChange(&mut self, newTempo: f64) {
        soundtouch_SoundTouch_setTempoChange(self, newTempo)
    }
    #[inline]
    pub unsafe fn setPitch(&mut self, newPitch: f64) {
        soundtouch_SoundTouch_setPitch(self, newPitch)
    }
    #[inline]
    pub unsafe fn setPitchOctaves(&mut self, newPitch: f64) {
        soundtouch_SoundTouch_setPitchOctaves(self, newPitch)
    }
    #[inline]
    pub unsafe fn setPitchSemiTones(&mut self, newPitch: ::std::os::raw::c_int) {
        soundtouch_SoundTouch_setPitchSemiTones(self, newPitch)
    }
    #[inline]
    pub unsafe fn setPitchSemiTones1(&mut self, newPitch: f64) {
        soundtouch_SoundTouch_setPitchSemiTones1(self, newPitch)
    }
    #[inline]
    pub unsafe fn setChannels(&mut self, numChannels: uint) {
        soundtouch_SoundTouch_setChannels(self, numChannels)
    }
    #[inline]
    pub unsafe fn setSampleRate(&mut self, srate: uint) {
        soundtouch_SoundTouch_setSampleRate(self, srate)
    }
    #[inline]
    pub unsafe fn getInputOutputSampleRatio(&mut self) -> f64 {
        soundtouch_SoundTouch_getInputOutputSampleRatio(self)
    }
    #[inline]
    pub unsafe fn flush(&mut self) {
        soundtouch_SoundTouch_flush(self)
    }
    #[inline]
    pub unsafe fn setSetting(
        &mut self,
        settingId: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    ) -> bool {
        soundtouch_SoundTouch_setSetting(self, settingId, value)
    }
    #[inline]
    pub unsafe fn getSetting(&self, settingId: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        soundtouch_SoundTouch_getSetting(self, settingId)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        soundtouch_SoundTouch_SoundTouch(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouchD1Ev"]
    pub fn soundtouch_SoundTouch_SoundTouch_destructor(this: *mut soundtouch_SoundTouch);
}
extern "C" {
    #[doc = " Adds 'numSamples' pcs of samples from the 'samples' memory position into\n the input of the object. Notice that sample rate _has_to_ be set before\n calling this function, otherwise throws a runtime_error exception."]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch10putSamplesEPKfj"]
    pub fn soundtouch_SoundTouch_putSamples(
        this: *mut ::std::os::raw::c_void,
        samples: *const soundtouch_SAMPLETYPE,
        numSamples: uint,
    );
}
extern "C" {
    #[doc = " Output samples from beginning of the sample buffer. Copies requested samples to\n output buffer and removes them from the sample buffer. If there are less than\n 'numsample' samples in the buffer, returns all that available.\n\n \\return Number of samples returned."]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch14receiveSamplesEPfj"]
    pub fn soundtouch_SoundTouch_receiveSamples(
        this: *mut ::std::os::raw::c_void,
        output: *mut soundtouch_SAMPLETYPE,
        maxSamples: uint,
    ) -> uint;
}
extern "C" {
    #[doc = " Adjusts book-keeping so that given number of samples are removed from beginning of the\n sample buffer without copying them anywhere.\n\n Used to reduce the number of samples in the buffer when accessing the sample buffer directly\n with 'ptrBegin' function."]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch14receiveSamplesEj"]
    pub fn soundtouch_SoundTouch_receiveSamples1(
        this: *mut ::std::os::raw::c_void,
        maxSamples: uint,
    ) -> uint;
}
extern "C" {
    #[doc = " Clears all the samples in the object's output and internal processing\n buffers."]
    #[link_name = "\u{1}_ZN10soundtouch10SoundTouch5clearEv"]
    pub fn soundtouch_SoundTouch_clear(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Returns number of samples currently unprocessed."]
    #[link_name = "\u{1}_ZNK10soundtouch10SoundTouch21numUnprocessedSamplesEv"]
    pub fn soundtouch_SoundTouch_numUnprocessedSamples(this: *mut ::std::os::raw::c_void) -> uint;
}
#[doc = " Rate transposer class instance"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RateTransposer {
    pub _address: u8,
}
#[doc = " Time-stretch class instance"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TDStretch {
    pub _address: u8,
}
